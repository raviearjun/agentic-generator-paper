@prefix : <http://www.w3id.org/agentic-ai/onto#> .
@prefix pp: <http://purl.org/net/p-plan#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix beam: <http://w3id.org/beam/core#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@base <http://www.w3id.org/agentic-ai/onto#> .
@prefix agento-ext: <http://www.w3id.org/agentic-ai/ext#> .

# Execution time: 127.47 seconds
# Model used: gpt-5-mini

# Issues / Assumptions:
# - The ontology does not include a property to express the crew-level "process" (e.g., sequential). I modelled workflow sequencing via WorkflowPattern, WorkflowStep, stepOrder, and nextStep.
# - Agent delegation flags (allow_delegation) and runtime methods (kickoff, train, verbose) from the code are framework-specific behaviors and are not represented because the ontology has no properties for execution control or training parameters.
# - The tasks' "expected_output" is not a defined property on Task in the ontology. I preserved this information by placing it into Task-associated Prompt.promptOutputIndicator.
# - Configuration files (paths) and the code-level binding between decorators and runtime creation are implementation details; I represented configs as Config individuals with repeated configKey/configValue pairs. The ontology lacks a structured key-value map type, so each key/value is modeled as a separate Config individual.
# - File-system paths and SDK-specific constructs (e.g., Agent(...), Crew(...), Process.sequential) are not modelled, as requested.
# - The ontology lacks explicit properties for "training iterations" and "training output filename". Those runtime details are omitted.
# - Placeholder usage (e.g., {game} interpolation) is preserved in promptInstruction and promptInputData as literal strings, but the ontology does not provide a native template/parameterization mechanism.
# - No explicit Tool individuals separate from LLMAgents were required by the code, so agents are modelled as LLMAgent (they are also Tools by ontology subclassing).
# - No HumanAgent instances were present in the code; none are created.

#################################################################
# Instances for GameBuilderCrew solution
#################################################################

### Team / Crew
:GameBuilderCrew rdf:type :Team ;
    rdfs:label "GameBuilderCrew" ;
    :hasAgentMember :senior_engineer_agent ,
                    :qa_engineer_agent ,
                    :chief_qa_engineer_agent ;
    :hasWorkflowPattern :GameBuilderWorkflow ;
    :hasSystemConfig :gamebuilder_system_config ;
    :hasTeamGoal :goal_create_game .

### Team-level goal
:goal_create_game rdf:type :Goal ;
    rdfs:label "Create Game (Team Goal)" ;
    <http://purl.org/dc/terms/description> """Produce a working python game implementation given a textual game description input. The system assembles agents and tasks to generate, review, and evaluate final python code for a game (examples include Pac-Man and Snake).""" .

### System configuration (crew)
:gamebuilder_system_config rdf:type :Config ;
    :configKey "agents_config" ;
    :configValue "config/agents.yaml" .

:gamebuilder_system_config_tasks rdf:type :Config ;
    :configKey "tasks_config" ;
    :configValue "config/tasks.yaml" .

#################################################################
# Language Model(s)
#################################################################

:gpt_model_1 rdf:type :LanguageModel ;
    rdfs:label "default LLM (unspecified, used by agents)" ;
    <http://purl.org/dc/terms/description> "A language model used by the LLMAgents. In the source system this is the underlying LLM backing Crew Agents (not further specified in code)." .

#################################################################
# Agents (LLMAgent)
#################################################################

### Senior Engineer Agent
:senior_engineer_agent rdf:type :LLMAgent ;
    rdfs:label "senior_engineer_agent" ;
    :agentID "senior_engineer_agent" ;
    :agentRole "Senior Software Engineer" ;
    :hasAgentConfig :senior_engineer_config_role ,
                    :senior_engineer_config_goal ,
                    :senior_engineer_config_backstory ;
    :hasAgentGoal :goal_create_software ;
    :agentPrompt :senior_engineer_prompt ;
    :useLanguageModel :gpt_model_1 .

:goal_create_software rdf:type :Goal ;
    rdfs:label "Create software as needed" ;
    <http://purl.org/dc/terms/description> "Create software as needed" .

:senior_engineer_config_role rdf:type :Config ;
    :configKey "role" ;
    :configValue """Senior Software Engineer""" .

:senior_engineer_config_goal rdf:type :Config ;
    :configKey "goal" ;
    :configValue """Create software as needed""" .

:senior_engineer_config_backstory rdf:type :Config ;
    :configKey "backstory" ;
    :configValue """You are a Senior Software Engineer at a leading tech think tank.
Your expertise in programming in python. and do your best to produce perfect code""" .

:senior_engineer_prompt rdf:type :Prompt ;
    rdfs:label "senior_engineer_agent prompt" ;
    :promptInstruction """You are a Senior Software Engineer at a leading tech think tank.
Your expertise in programming in python. and do your best to produce perfect code""" ;
    :promptContext "Role: Senior Software Engineer" ;
    :promptOutputIndicator "Produce the full python code for the requested game. Output must be only the python code and nothing else." .

### QA Engineer Agent
:qa_engineer_agent rdf:type :LLMAgent ;
    rdfs:label "qa_engineer_agent" ;
    :agentID "qa_engineer_agent" ;
    :agentRole "Software Quality Control Engineer" ;
    :hasAgentConfig :qa_engineer_config_role ,
                    :qa_engineer_config_goal ,
                    :qa_engineer_config_backstory ;
    :hasAgentGoal :goal_create_perfect_code ;
    :agentPrompt :qa_engineer_prompt ;
    :useLanguageModel :gpt_model_1 .

:goal_create_perfect_code rdf:type :Goal ;
    rdfs:label "Create Perfect code" ;
    <http://purl.org/dc/terms/description> "Create Perfect code, by analyzing the code that is given for errors" .

:qa_engineer_config_role rdf:type :Config ;
    :configKey "role" ;
    :configValue """Software Quality Control Engineer""" .

:qa_engineer_config_goal rdf:type :Config ;
    :configKey "goal" ;
    :configValue """Create Perfect code, by analyzing the code that is given for errors""" .

:qa_engineer_config_backstory rdf:type :Config ;
    :configKey "backstory" ;
    :configValue """You are a software engineer that specializes in checking code
for errors. You have an eye for detail and a knack for finding
hidden bugs.
You check for missing imports, variable declarations, mismatched
brackets and syntax errors.
You also check for security vulnerabilities, and logic errors""" .

:qa_engineer_prompt rdf:type :Prompt ;
    rdfs:label "qa_engineer_agent prompt" ;
    :promptInstruction """You are a software engineer that specializes in checking code
for errors. You have an eye for detail and a knack for finding
hidden bugs.
You check for missing imports, variable declarations, mismatched
brackets and syntax errors.
You also check for security vulnerabilities, and logic errors""" ;
    :promptContext "Role: Software Quality Control Engineer" ;
    :promptOutputIndicator "Produce the corrected and validated full python code only, nothing else." .

### Chief QA Engineer Agent
:chief_qa_engineer_agent rdf:type :LLMAgent ;
    rdfs:label "chief_qa_engineer_agent" ;
    :agentID "chief_qa_engineer_agent" ;
    :agentRole "Chief Software Quality Control Engineer" ;
    :hasAgentConfig :chief_qa_engineer_config_role ,
                    :chief_qa_engineer_config_goal ,
                    :chief_qa_engineer_config_backstory ;
    :hasAgentGoal :goal_ensure_code_does_job ;
    :agentPrompt :chief_qa_engineer_prompt ;
    :useLanguageModel :gpt_model_1 .

:goal_ensure_code_does_job rdf:type :Goal ;
    rdfs:label "Ensure the code does the job that it is supposed to do" ;
    <http://purl.org/dc/terms/description> "Ensure that the code fulfills the functional requirements of the game description and is complete." .

:chief_qa_engineer_config_role rdf:type :Config ;
    :configKey "role" ;
    :configValue """Chief Software Quality Control Engineer""" .

:chief_qa_engineer_config_goal rdf:type :Config ;
    :configKey "goal" ;
    :configValue """Ensure that the code does the job that it is supposed to do""" .

:chief_qa_engineer_config_backstory rdf:type :Config ;
    :configKey "backstory" ;
    :configValue """You feel that programmers always do only half the job, so you are
super dedicate to make high quality code.""" .

:chief_qa_engineer_prompt rdf:type :Prompt ;
    rdfs:label "chief_qa_engineer_agent prompt" ;
    :promptInstruction """You feel that programmers always do only half the job, so you are
super dedicate to make high quality code.""" ;
    :promptContext "Role: Chief Software Quality Control Engineer" ;
    :promptOutputIndicator "Produce the final vetted python code only." .

#################################################################
# Tasks
#################################################################

### Code Task
:code_task rdf:type :Task ;
    rdfs:label "code_task" ;
    <http://purl.org/dc/terms/description> """You will create a game using python, these are the instructions:

Instructions
------------
{game}""" ;
    :taskPrompt :code_task_prompt ;
    :performedByAgent :senior_engineer_agent ;
    :producedResource :initial_game_code_resource .

:code_task_prompt rdf:type :Prompt ;
    rdfs:label "code_task prompt" ;
    :promptInstruction """You will create a game using python, these are the instructions:

Instructions
------------
{game}""" ;
    :promptInputData "{game}" ;
    :promptOutputIndicator "Your Final answer must be the full python code, only the python code and nothing else." .

:initial_game_code_resource rdf:type beam:Resource ;
    rdfs:label "initial_game_code" ;
    <http://purl.org/dc/terms/description> "Python code produced by senior_engineer_agent in response to the game description input." .

### Review Task
:review_task rdf:type :Task ;
    rdfs:label "review_task" ;
    <http://purl.org/dc/terms/description> """You will create a game using python, these are the instructions:

Instructions
------------
{game}

Using the code you got, check for errors. Check for logic errors,
syntax errors, missing imports, variable declarations, mismatched brackets,
and security vulnerabilities.
""" ;
    :taskPrompt :review_task_prompt ;
    :performedByAgent :qa_engineer_agent ;
    :requiresResource :initial_game_code_resource ;
    :producedResource :reviewed_game_code_resource .

:review_task_prompt rdf:type :Prompt ;
    rdfs:label "review_task prompt" ;
    :promptInstruction """You will create a game using python, these are the instructions:

Instructions
------------
{game}

Using the code you got, check for errors. Check for logic errors,
syntax errors, missing imports, variable declarations, mismatched brackets,
and security vulnerabilities.
""" ;
    :promptInputData "{game} + code from previous step" ;
    :promptOutputIndicator "Your Final answer must be the full python code, only the python code and nothing else." .

:reviewed_game_code_resource rdf:type beam:Resource ;
    rdfs:label "reviewed_game_code" ;
    <http://purl.org/dc/terms/description> "Code after QA review by qa_engineer_agent; errors fixed and issues annotated in code response (final output is the corrected python code)." .

### Evaluate Task
:evaluate_task rdf:type :Task ;
    rdfs:label "evaluate_task" ;
    <http://purl.org/dc/terms/description> """You are helping create a game using python, these are the instructions:

Instructions
------------
{game}

You will look over the code to insure that it is complete and
does the job that it is supposed to do.
""" ;
    :taskPrompt :evaluate_task_prompt ;
    :performedByAgent :chief_qa_engineer_agent ;
    :requiresResource :reviewed_game_code_resource ;
    :producedResource :final_game_code_resource .

:evaluate_task_prompt rdf:type :Prompt ;
    rdfs:label "evaluate_task prompt" ;
    :promptInstruction """You are helping create a game using python, these are the instructions:

Instructions
------------
{game}

You will look over the code to insure that it is complete and
does the job that it is supposed to do.
""" ;
    :promptInputData "{game} + reviewed code" ;
    :promptOutputIndicator "Your Final answer must be the full python code, only the python code and nothing else." .

:final_game_code_resource rdf:type beam:Resource ;
    rdfs:label "final_game_code" ;
    <http://purl.org/dc/terms/description> """Final python code for the requested game after generation, review, and evaluation steps. Example inputs available in src/game_builder_crew/config/gamedesign.yaml (example1_pacman, example2_pacman, example3_snake).""" .

#################################################################
# Workflow Pattern and Steps
#################################################################

:GameBuilderWorkflow rdf:type :WorkflowPattern ;
    rdfs:label "Game Builder Sequential Workflow" ;
    :hasWorkflowStep :step_code ,
                     :step_review ,
                     :step_evaluate ;
    <http://purl.org/dc/terms/description> "A sequential workflow where code is produced, reviewed, and evaluated to produce final game code." ;
    :hasRelatedPattern :GameBuilderWorkflow .  # self-reference to indicate it's a pattern (allowed by hasRelatedPattern)

:step_code rdf:type :StartStep ;
    rdfs:label "step_code" ;
    :hasAssociatedTask :code_task ;
    :stepOrder 1 ;
    :nextStep :step_review .

:step_review rdf:type :WorkflowStep ;
    rdfs:label "step_review" ;
    :hasAssociatedTask :review_task ;
    :stepOrder 2 ;
    :nextStep :step_evaluate .

:step_evaluate rdf:type :EndStep ;
    rdfs:label "step_evaluate" ;
    :hasAssociatedTask :evaluate_task ;
    :stepOrder 3 .

#################################################################
# Examples / Inputs (preserved game descriptions)
#################################################################

:example1_pacman rdf:type :Instance ;
    rdfs:label "example1_pacman input" ;
    <http://purl.org/dc/terms/description> """Game Overview:

Pac-Man is a classic arcade game where the player controls a character, Pac-Man, through a maze. The objective is to eat all the pellets in the maze while avoiding four ghosts that pursue Pac-Man. If Pac-Man eats a large power pellet, the ghosts turn blue, and Pac-Man can eat them for extra points. 
The game is over when Pac-Man is caught by a ghost or when the player runs out of lives.
Core Game Elements:

    Maze Layout:
        The game is set within a grid-like maze. The walls are solid, and Pac-Man cannot pass through them.
        The maze contains corridors where Pac-Man can move in four directions: up, down, left, and right. Some sections of the maze loop back on themselves.
        The maze contains two types of special tiles:
            Pellets: Small dots scattered throughout the maze, worth 10 points each.
            Power Pellets: Larger dots placed in the four corners of the maze, worth 50 points each. Eating a Power Pellet allows Pac-Man to eat the ghosts for a limited time. Eating a Power Pellet allows Pac-Man to turn the ghosts blue for a short period (usually 7-10 seconds). During this time, Pac-Man can eat the ghosts for extra points. Ghosts revert to their regular form after the time limit.

    Player Controls:
        The player controls Pac-Man's movement using arrow keys (or other directional inputs, such as WASD).
        Pac-Man moves continuously in the chosen direction until blocked by a wall or until the player changes direction.
        Pac-Man cannot stop moving, so the player must carefully time movements and changes in direction.

    Pac-Man Mechanics:
        Movement: Pac-Man moves one tile at a time in a grid-based movement system.
        Collision Detection: Pac-Man collides with walls, pellets, power pellets, and ghosts. Pac-Man cannot pass through walls.
        Pellet Collection: When Pac-Man moves onto a tile containing a pellet, it is "eaten," and the pellet disappears.
        Power Pellet Effects: Eating a Power Pellet allows Pac-Man to turn the ghosts blue for a short period (usually 7-10 seconds). During this time, Pac-Man can eat the ghosts for extra points. Ghosts revert to their regular form after the time limit.

    Ghosts:
        There are four ghosts: Blinky, Pinky, Inky, and Clyde. Each has a distinct behavior pattern:
            Blinky (Red Ghost): Aggressively pursues Pac-Man, always targeting his current location.
            Pinky (Pink Ghost): Attempts to ambush Pac-Man by aiming four tiles ahead of Pac-Man's current direction.
            Inky (Cyan Ghost): Has a more complex behavior, targeting an area between Pac-Man and Blinky's current location.
            Clyde (Orange Ghost): Alternates between chasing Pac-Man and wandering randomly when he gets too close to Pac-Man.
        Ghost Movement: Ghosts move one tile at a time, just like Pac-Man, and they can change directions at intersections. Their goal is to catch Pac-Man.
        Ghost States:
            Chase Mode: Ghosts actively pursue Pac-Man based on their unique behavior patterns.
            Scatter Mode: Ghosts move to specific corners of the maze, where they “scatter” and remain for a brief period before returning to Chase mode.
            Frightened Mode: After Pac-Man eats a Power Pellet, ghosts turn blue and flee from Pac-Man. In this mode, Pac-Man can eat them for extra points. When a ghost is eaten, it respawns at the center of the maze and resumes chasing Pac-Man.

    Scoring System:
        Eating a pellet: 10 points.
        Eating a Power Pellet: 50 points.
        Eating a ghost (in Frightened mode):
            First ghost: 200 points.
            Second ghost: 400 points.
            Third ghost: 800 points.
            Fourth ghost: 1600 points.
        Clearing a level (eating all the pellets): Bonus points for completing the level.

    Lives and Game Over:
        Pac-Man starts the game with 3 lives.
        If a ghost touches Pac-Man while in its normal or chase mode, Pac-Man loses a life.
        When all lives are lost, the game ends.

    Level Progression:
        After all pellets and Power Pellets are consumed in the maze, Pac-Man progresses to the next level.
        Each new level increases the game difficulty, making the ghosts move faster.
        At higher levels, the time that ghosts remain blue after eating a Power Pellet decreases, eventually reaching a point where they no longer turn blue.

    Warp Tunnels:
        The maze has two special tunnels on the left and right edges that act as "warp tunnels."
        When Pac-Man or the ghosts enter one side, they instantly reappear on the opposite side of the maze.

Mechanics Used in the Game:

    Tile-Based Movement:
        The entire game operates on a grid, where each movement happens from one tile to another. Both Pac-Man and the ghosts must follow the grid's structure.

    Pathfinding (Ghost AI):
        The ghosts use basic pathfinding algorithms to chase Pac-Man. One common method for this is the A algorithm* or a simplified greedy algorithm to determine the shortest path toward Pac-Man.
        Each ghost has its unique targeting behavior, ranging from direct pursuit to attempting ambush strategies.

    State Management:
        Pac-Man's State: Handles whether Pac-Man is in a normal state, Power Pellet state (can eat ghosts), or has collided with a ghost.
        Ghosts' State: Manages transitions between three ghost states:
            Chase State: Actively chasing Pac-Man.
            Scatter State: Retreats to their designated corners.
            Frightened State: Turns blue and flees from Pac-Man, allowing Pac-Man to eat them.

    Collision Detection:
        Pellets and Pac-Man: When Pac-Man's position matches a pellet's position, the pellet is eaten.
        Ghosts and Pac-Man: When Pac-Man's position matches a ghost's position:
            If the ghost is in Frightened mode, Pac-Man eats the ghost.
            If the ghost is in Chase or Scatter mode, Pac-Man loses a life.

    Timer and Speed Control:
        The game runs on a time-based loop where Pac-Man and the ghosts move at set intervals.
        Ghosts' speeds increase over time, making higher levels more difficult.

    Level Design and Randomness:
        While the layout of the maze stays the same, the randomness in ghost behavior and increasing speed add variability to each playthrough.

    Game Over Conditions:
        When Pac-Man has no remaining lives, the game ends, displaying a "Game Over" screen.
        The players final score is shown""" .

:example2_pacman rdf:type :Instance ;
    rdfs:label "example2_pacman input" ;
    <http://purl.org/dc/terms/description> "Build a Pacman game, where the pacman moves up, down, left, right with the use of keyboard arrows. each food dot he eats, he gets a point. ghosts appear at random times and move randomly and if they hit pacman, it loses a life, he has three lives, then game over. if he finishes all food points in one level, he moves on to the next level, in which pacman moves faster, and more ghosts appear." .

:example3_snake rdf:type :Instance ;
    rdfs:label "example3_snake input" ;
    <http://purl.org/dc/terms/description> """Snake Game Description
Objective:

The objective of the Snake game is for the player to control a snake that moves across the game area, consuming food while avoiding obstacles, including its own tail. The snake grows longer each time it consumes food, and the game continues until the snake collides with the boundaries of the game area or its own body.
Game Mechanics:

Game Area:
    The game takes place in a rectangular grid, typically represented as a 2D matrix or array.
    The grid contains cells, where the snake can move and food can spawn.

Snake Movement:
    The snake is controlled by the player, typically through arrow keys (Up, Down, Left, Right) or WASD keys.
    The snake moves continuously in one direction until the player changes its direction.
    Movement is discrete, with the snake advancing one cell per frame or tick.
    The snake's body consists of connected segments that follow the movement of the head, forming a continuous line.

Growth Mechanism:
    The snake starts with a default length (e.g., 3 segments) and grows longer by one segment every time it eats food.
    The new segment is added to the end of the snake's body after consuming food.

Food:
    Randomly spawns at an unoccupied position in the game area (i.e., not on the snake's body).
    Each piece of food can only be consumed once.
    After being consumed, a new piece of food spawns at another random position.

Collisions:
    The game ends when the snake collides with any of the following:
        Walls: The boundaries of the game area.
        Self: The snake's own body.

Game Rules:

Movement:
    The snake moves continuously, and the player can change its direction using input keys.
    The snake cannot move in the opposite direction of its current movement (e.g., if moving right, it cannot immediately move left).

Boundaries:
    The edges of the grid act as walls. If the snake crosses these boundaries, the game is over.

Self-Collision:
    The snake's body grows as it consumes food, but if the snake's head touches any part of its body, the game ends.

Scoring System:

Food Consumption:
    Every time the snake eats a piece of food, the player earns points.
    The typical scoring system could be:
        10 points per food item consumed.
    The score increases with each successful food consumption.

Time or Speed-Based Scoring (Optional):
    Additional points can be awarded based on how long the player survives, or the game can speed up as the snake grows, increasing difficulty over time.

High Score:
    The player's current score is displayed during gameplay.
    A high-score system can be implemented to keep track of the highest score achieved. """ .

#################################################################
# Links between tasks and examples (inputs used at runtime)
#################################################################

# The crew runtime uses 'inputs' mapping 'game' to an example such as example3_snake when kickoff/train is invoked.
:runtime_inputs_example3 rdf:type :Context ;
    rdfs:label "runtime inputs example (snake)" ;
    <http://purl.org/dc/terms/description> "The runtime inputs map contains key 'game' -> example3_snake (see example3_snake instance)." ;
    :containsResource :example3_snake .

#################################################################
# End of instance population
#################################################################

################################################################################
# KickoffInputBundle (agento-ext) — Uniform runtime inputs for pipeline extraction
################################################################################

:KickoffInput_game a agento-ext:KickoffInputBundle ;
    agento-ext:inputKey "game" ;
    agento-ext:inputValue """Snake Game Description
Objective:

The objective of the Snake game is for the player to control a snake that moves across the game area, consuming food while avoiding obstacles, including its own tail. The snake grows longer each time it consumes food, and the game continues until the snake collides with the boundaries of the game area or its own body.
Game Mechanics:

Game Area:
    The game takes place in a rectangular grid, typically represented as a 2D matrix or array.
    The grid contains cells, where the snake can move and food can spawn.

Snake Movement:
    The snake is controlled by the player, typically through arrow keys (Up, Down, Left, Right) or WASD keys.
    The snake moves continuously in one direction until the player changes its direction.
    Movement is discrete, with the snake advancing one cell per frame or tick.
    The snake's body consists of connected segments that follow the movement of the head, forming a continuous line.

Growth Mechanism:
    The snake starts with a default length (e.g., 3 segments) and grows longer by one segment every time it eats food.
    The new segment is added to the end of the snake's body after consuming food.

Food:
    Randomly spawns at an unoccupied position in the game area (i.e., not on the snake's body).
    Each piece of food can only be consumed once.
    After being consumed, a new piece of food spawns at another random position.

Collisions:
    The game ends when the snake collides with any of the following:
        Walls: The boundaries of the game area.
        Self: The snake's own body.

Game Rules:

Movement:
    The snake moves continuously, and the player can change its direction using input keys.
    The snake cannot move in the opposite direction of its current movement (e.g., if moving right, it cannot immediately move left).

Boundaries:
    The edges of the grid act as walls. If the snake crosses these boundaries, the game is over.

Self-Collision:
    The snake's body grows as it consumes food, but if the snake's head touches any part of its body, the game ends.

Scoring System:

Food Consumption:
    Every time the snake eats a piece of food, the player earns points.
    The typical scoring system could be:
        10 points per food item consumed.
    The score increases with each successful food consumption.

Time or Speed-Based Scoring (Optional):
    Additional points can be awarded based on how long the player survives, or the game can speed up as the snake grows, increasing difficulty over time.

High Score:
    The player's current score is displayed during gameplay.
    A high-score system can be implemented to keep track of the highest score achieved. """ ;
    agento-ext:isDefaultValue true .

:KickoffInput_game_example1_pacman a agento-ext:KickoffInputBundle ;
    agento-ext:inputKey "game" ;
    agento-ext:inputValue """Game Overview:

Pac-Man is a classic arcade game where the player controls a character, Pac-Man, through a maze. The objective is to eat all the pellets in the maze while avoiding four ghosts that pursue Pac-Man. If Pac-Man eats a large power pellet, the ghosts turn blue, and Pac-Man can eat them for extra points. 
The game is over when Pac-Man is caught by a ghost or when the player runs out of lives.
Core Game Elements:

    Maze Layout:
        The game is set within a grid-like maze. The walls are solid, and Pac-Man cannot pass through them.
        The maze contains corridors where Pac-Man can move in four directions: up, down, left, and right. Some sections of the maze loop back on themselves.
        The maze contains two types of special tiles:
            Pellets: Small dots scattered throughout the maze, worth 10 points each.
            Power Pellets: Larger dots placed in the four corners of the maze, worth 50 points each. Eating a Power Pellet allows Pac-Man to eat the ghosts for a limited time. Eating a Power Pellet allows Pac-Man to turn the ghosts blue for a short period (usually 7-10 seconds). During this time, Pac-Man can eat the ghosts for extra points. Ghosts revert to their regular form after the time limit.

    Player Controls:
        The player controls Pac-Man's movement using arrow keys (or other directional inputs, such as WASD).
        Pac-Man moves continuously in the chosen direction until blocked by a wall or until the player changes direction.
        Pac-Man cannot stop moving, so the player must carefully time movements and changes in direction.

    Pac-Man Mechanics:
        Movement: Pac-Man moves one tile at a time in a grid-based movement system.
        Collision Detection: Pac-Man collides with walls, pellets, power pellets, and ghosts. Pac-Man cannot pass through walls.
        Pellet Collection: When Pac-Man moves onto a tile containing a pellet, it is "eaten," and the pellet disappears.
        Power Pellet Effects: Eating a Power Pellet allows Pac-Man to turn the ghosts blue for a short period (usually 7-10 seconds). During this time, Pac-Man can eat the ghosts for extra points. Ghosts revert to their regular form after the time limit.

    Ghosts:
        There are four ghosts: Blinky, Pinky, Inky, and Clyde. Each has a distinct behavior pattern:
            Blinky (Red Ghost): Aggressively pursues Pac-Man, always targeting his current location.
            Pinky (Pink Ghost): Attempts to ambush Pac-Man by aiming four tiles ahead of Pac-Man's current direction.
            Inky (Cyan Ghost): Has a more complex behavior, targeting an area between Pac-Man and Blinky's current location.
            Clyde (Orange Ghost): Alternates between chasing Pac-Man and wandering randomly when he gets too close to Pac-Man.
        Ghost Movement: Ghosts move one tile at a time, just like Pac-Man, and they can change directions at intersections. Their goal is to catch Pac-Man.
        Ghost States:
            Chase Mode: Ghosts actively pursue Pac-Man based on their unique behavior patterns.
            Scatter Mode: Ghosts move to specific corners of the maze, where they "scatter" and remain for a brief period before returning to Chase mode.
            Frightened Mode: After Pac-Man eats a Power Pellet, ghosts turn blue and flee from Pac-Man. In this mode, Pac-Man can eat them for extra points. When a ghost is eaten, it respawns at the center of the maze and resumes chasing Pac-Man.

    Scoring System:
        Eating a pellet: 10 points.
        Eating a Power Pellet: 50 points.
        Eating a ghost (in Frightened mode):
            First ghost: 200 points.
            Second ghost: 400 points.
            Third ghost: 800 points.
            Fourth ghost: 1600 points.
        Clearing a level (eating all the pellets): Bonus points for completing the level.

    Lives and Game Over:
        Pac-Man starts the game with 3 lives.
        If a ghost touches Pac-Man while in its normal or chase mode, Pac-Man loses a life.
        When all lives are lost, the game ends.

    Level Progression:
        After all pellets and Power Pellets are consumed in the maze, Pac-Man progresses to the next level.
        Each new level increases the game difficulty, making the ghosts move faster.
        At higher levels, the time that ghosts remain blue after eating a Power Pellet decreases, eventually reaching a point where they no longer turn blue.

    Warp Tunnels:
        The maze has two special tunnels on the left and right edges that act as "warp tunnels."
        When Pac-Man or the ghosts enter one side, they instantly reappear on the opposite side of the maze.

Mechanics Used in the Game:

    Tile-Based Movement:
        The entire game operates on a grid, where each movement happens from one tile to another. Both Pac-Man and the ghosts must follow the grid's structure.

    Pathfinding (Ghost AI):
        The ghosts use basic pathfinding algorithms to chase Pac-Man. One common method for this is the A algorithm* or a simplified greedy algorithm to determine the shortest path toward Pac-Man.
        Each ghost has its unique targeting behavior, ranging from direct pursuit to attempting ambush strategies.

    State Management:
        Pac-Man's State: Handles whether Pac-Man is in a normal state, Power Pellet state (can eat ghosts), or has collided with a ghost.
        Ghosts' State: Manages transitions between three ghost states:
            Chase State: Actively chasing Pac-Man.
            Scatter State: Retreats to their designated corners.
            Frightened State: Turns blue and flees from Pac-Man, allowing Pac-Man to eat them.

    Collision Detection:
        Pellets and Pac-Man: When Pac-Man's position matches a pellet's position, the pellet is eaten.
        Ghosts and Pac-Man: When Pac-Man's position matches a ghost's position:
            If the ghost is in Frightened mode, Pac-Man eats the ghost.
            If the ghost is in Chase or Scatter mode, Pac-Man loses a life.

    Timer and Speed Control:
        The game runs on a time-based loop where Pac-Man and the ghosts move at set intervals.
        Ghosts' speeds increase over time, making higher levels more difficult.

    Level Design and Randomness:
        While the layout of the maze stays the same, the randomness in ghost behavior and increasing speed add variability to each playthrough.

    Game Over Conditions:
        When Pac-Man has no remaining lives, the game ends, displaying a "Game Over" screen.
        The players final score is shown""" ;
    agento-ext:isDefaultValue false .

:KickoffInput_game_example2_pacman a agento-ext:KickoffInputBundle ;
    agento-ext:inputKey "game" ;
    agento-ext:inputValue "Build a Pacman game, where the pacman moves up, down, left, right with the use of keyboard arrows. each food dot he eats, he gets a point. ghosts appear at random times and move randomly and if they hit pacman, it loses a life, he has three lives, then game over. if he finishes all food points in one level, he moves on to the next level, in which pacman moves faster, and more ghosts appear." ;
    agento-ext:isDefaultValue false .
